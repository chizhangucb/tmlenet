# ---------------------------------------------------------------------------------------------------------
# Test network TMLE fit with continous sA 
# TO DO: NEED TO EVALUTE COVERAGE CONDITIONAL ON 1 NETWORK!!!! (No network resampling for each simulation)
# ---------------------------------------------------------------------------------------------------------
# TMLE for causal effect in network data with continuous exposure under continuous stochastic intervention;
# intervention g.star is defined by shifting the normal density of observed sA until g.star/g.0 >= 10,
# then its truncated to be equal to g.0

run.net.1sim.tmlenet <- function(datO, NetInd_mat, def_sW, def_sA, Kmax, Qform, f.gstar, psi0) {
  # NetInd_mat <- attributes(datO)$netind_cl$NetInd
  # def_sW <- def.sW(W1 = "W1", W2 = "W2", W3 = "W3")
  # def_sA <- def.sA(sA = "sA", net.mean.sA = rowMeans(sA[[1:Kmax]]), replaceNAw0 = TRUE)
  datO_input <- datO[,c("W1", "W2", "W3", "sA", "Y")]
  res <- tmlenet(data = datO_input, Anode = "sA", Wnodes = c("W1", "W2", "W3"), Ynode = "Y",
                  Kmax = Kmax,
                  NETIDs_mat = NetInd_mat,
                  # nFnode = NULL,
                  f_gstar1 = f.gstar,
                  sW = def_sW, sA = def_sA,
                  Qform = Qform,
                  # correct Q:
                  # Qform = "Y ~ W1 + W2 + W3 + sA + net.mean.sA",
                  # misspecified Q:
                  # Qform = "Y ~ W2 + W3 + net.mean.sA",
                  hform = "sA + net.mean.sA ~ W1 + W2 + W3",
                  hform.gstar = "sA + net.mean.sA ~ W1 + W2 + W3",
                  gform = "sA ~ W1 + W2 + W3",
                  optPars = list(
                    # f_g0 = f.A, # tested, works
                    n_MCsims = 10)
                  )

  CIs <- res$EY_gstar1$CIs
  print("CIs: "); print(CIs)
  (tmle_B.CI <- CIs[rownames(CIs)%in%"tmle_B",])
  (h_iptw.CI <- CIs[rownames(CIs)%in%"h_iptw",])
  cover.tmle_B <- ((psi0 <= tmle_B.CI[2]) && (psi0 >= tmle_B.CI[1]))
  cover.h_iptw <- ((psi0 <= h_iptw.CI[2]) && (psi0 >= h_iptw.CI[1]))

  est_mat <- res$EY_gstar1$estimates
  est <- as.vector(est_mat)
  names(est) <- rownames(est_mat)
  cover <- apply(CIs, 1, function(row) ((psi0 <= row[2]) && (psi0 >= row[1])))
  cover2 <- c(tmle_B = cover.tmle_B, h_iptw = cover.h_iptw)

  return(list(est = est, cover = cover))
}


# Run one TMLE simulation for network data generated igraph::sample_k_regular (all nodes have the same degree k)
# estimate psi0 under trunced g.star (same as in iid)
# sA is the same as in iid example w sAnet=(sA, rowMeans(sA[[1:Kmax]])).
# TO TRY: Generate network using current gennetwork, simpler gennetwork that samples from uniform and network generated by igraph
# Used for Verifying: 1) consistency, 2) double robustness, 3) correct as. coverage
test.onesim.net.tmlefit <- function() {
  library(simcausal)
  library(tmlenet)
  #------------------------------------------------------------------------------------------------------------
  # The user-defined network sampler(s) from igraph (regular graph model)
  # Generate regular random graphs with same degree for each node
  # Kmax - degree of each node
  generate.igraph.k.regular <- function(n, Kmax, ...) {
    if (n < 20) Kmax <- 5
    igraph.reg <- igraph::sample_k_regular(no.of.nodes = n, k = Kmax, directed = TRUE, multiple = FALSE)
    # From igraph object to sparse adj. matrix:
    sparse_AdjMat <- simcausal:::igraph_to_sparseAdjMat(igraph.reg)
    # From igraph object to simcausal/tmlenet input (NetInd_k, nF, Kmax):
    NetInd_out <- simcausal:::sparseAdjMat_to_NetInd(sparse_AdjMat)
    print("old Kmax:" %+% Kmax)
    print("new Kmax:" %+% NetInd_out$Kmax)
    print("NetInd_k"); print(head(NetInd_out$NetInd_k))
    if (Kmax < NetInd_out$Kmax) message("new network has larger Kmax value than requested, new Kmax = " %+% NetInd_out$Kmax)
    return(NetInd_out$NetInd_k)
  }

  # graph <- igraph::sample_k_regular(no.of.nodes = 50, k = 10, directed = TRUE, multiple = FALSE)
  # par(mar=c(.1,.1,.1,.1))
  # igraph::plot.igraph(graph,
  #     layout=igraph::layout.fruchterman.reingold,
  #     vertex.size=7,
  #     vertex.label.cex=.5,
  #     edge.arrow.size=.5)

  Kmax <- 10
  trunc.const <- 10
  shift.const <- 2

  D <- DAG.empty()
  # Adding the ER model network generator from igraph:
  D <- D + network("NetInd_k", Kmax = Kmax, netfun = "generate.igraph.k.regular")

  D <-
  D + node("W1", distr = "rbern", prob = 0.5) +
      node("W2", distr = "rbern", prob = 0.3) +
      node("W3", distr = "rbern", prob = 0.3) +
      node("sA.mu", distr = "rconst", const = (0.98 * W1 + 0.58 * W2 + 0.33 * W3)) +
      node("shift",  distr = "rconst", const = .(shift.const)) +
      node("sA", distr = "rnorm", mean = sA.mu, sd = 1) +
      node("net.mean.sA", distr = "rconst", const = mean(sA[[1:Kmax]])) +
      node("r.obs.sA",  distr = "rconst", const = exp(shift * (sA - sA.mu - shift / 2))) +
      node("trunc.c",  distr = "rconst", const = .(trunc.const)) +
      node("untrunc.sA.gstar",  distr = "rconst", const = sA + shift) +
      # node("untrunc.sA.gstar",  distr = "rnorm", mean = sA.mu + shift, sd = 1) +
      # node("p.gstar.sA", distr = "rconst", const = (1/sqrt(2*.(pi))) * exp((-1/2) * (untrunc.sA.gstar - sA.mu)^2)) +
      # node("p.gstar.sA.gstar", distr = "rconst", const = (1/sqrt(2*.(pi))) * exp((-1/2) * (untrunc.sA.gstar - (sA.mu + shift))^2)) +
      node("r.new.sA",  distr = "rconst", const = exp(shift * (untrunc.sA.gstar - sA.mu - shift / 2))) +
      node("tr.sA.gstar",  distr = "rconst", const = ifelse(r.new.sA > trunc.c, sA, untrunc.sA.gstar)) +

      node("probY", distr = "rconst", const = plogis(-0.35 * sA - 0.20 * mean(sA[[1:Kmax]]) - 0.5 * W1 - 0.58 * W2 - 0.33 * W3)) +
      # node("probY", distr = "rconst", const = plogis(-0.35 * sA - 0.20 * sum(sA[[1:Kmax]]) / nF - 0.5 * W1 - 0.58 * W2 - 0.33 * W3)) +

      node("Y", distr = "rbern", prob = probY) +

      node("probY.gstar", distr = "rconst", const = plogis(-0.35 * tr.sA.gstar - 0.20 * mean(tr.sA.gstar[[1:Kmax]]) - 0.5 * W1 - 0.58 * W2 - 0.33 * W3)) +
      # node("probY.gstar", distr = "rconst", const = plogis(-0.35 * tr.sA.gstar - 0.20 * sum(tr.sA.gstar[[1:Kmax]]) / nF - 0.5 * W1 - 0.58 * W2 - 0.33 * W3)) +
      node("Y.gstar", distr = "rbern", prob = probY.gstar)

      # node("probY", distr = "rconst", const = plogis(-0.45 * sA - 0.5 * W1 - 0.58 * W2 - 0.33 * W3)) +
      # node("Y", distr = "rbern", prob = probY) +
      # node("probY.gstar", distr = "rconst", const = plogis(-0.45 * tr.sA.gstar - 0.5 * W1 - 0.58 * W2 - 0.33 * W3)) +
      # node("Y.gstar", distr = "rbern", prob = probY.gstar)

  Dset <- set.DAG(D)
  # plotDAG(Dset)

  # get true psi.0:
  # rndseed <- 12345
  rndseed2 <- 54321
  nsamp <- 50000
  t1 <- system.time(
    datFull <- sim(Dset, n = nsamp, rndseed = rndseed2)
  )
  t1
  # for 40K with Kmax=10
  # user  system elapsed 
  # 13.298   0.119  13.375
  # for 50K with Kmax=10
  # user  system elapsed 
  # 20.377   0.141  20.447 

  print(head(datFull, 50))
  # to get the network object from sim data:
  # netind_cl <- attributes(datFull)$netind_cl
  # to get the network matrix from sim data:
  # NetInd_mat <- attributes(datFull)$netind_cl$NetInd

  print("mean(datFull$Y): " %+% mean(datFull$Y));
  # [1] "mean(datFull$Y): 0.301425"
  psi0 <- mean(datFull$Y.gstar)
  print("psi0: " %+% psi0)
  # [1] "psi0: 0.189075"
  # [1] "psi0: 0.19184"


  # Stochastic intervention of interest, returns a vector of new treatment assignments sampled from shifted normal
  f.gstar <- function(data, ...) {
    sA.mu <- 0.98 * data[,"W1"] + 0.58 * data[,"W2"] + 0.33 * data[,"W3"]
    untrunc.sA <- rnorm(n = nrow(data), mean = sA.mu + shift.const, sd = 1)
    r.new.sA <- exp(shift.const * (untrunc.sA - sA.mu - shift.const / 2))
    trunc.sA <- ifelse(r.new.sA > trunc.const, untrunc.sA - shift.const, untrunc.sA)
    return(trunc.sA)
  }

  def_sW <- def.sW(W1 = "W1", W2 = "W2", W3 = "W3")
  def_sA <- def.sA(sA = "sA", net.mean.sA = rowMeans(sA[[1:Kmax]]), replaceNAw0 = TRUE)

  # # correct Q:
  Qform.corr <- "Y ~ W1 + W2 + W3 + sA + net.mean.sA"
  # # misspecified Q:
  # Qform.mis <- "Y ~ W3 + sA"
  Qform.mis <- "Y ~ W2 + W3 + net.mean.sA"
  Qforms <- c(Qform.corr = Qform.corr, Qform.mis = Qform.mis)

  # res <- run.net.1sim.tmlenet(datO, NetInd_mat, Kmax = Kmax, nsamp, Qform, f.gstar, trunc.const = 10, shift.const = 2)
  # rndseed <- 12345
  # datO <- sim(Dset, n = 5000, rndseed = rndseed)
  datO <- sim(Dset, n = 5000)
  netind_cl <- attributes(datO)$netind_cl
  NetInd_mat <- attributes(datO)$netind_cl$NetInd
  dim(NetInd_mat)
  simres <- run.net.1sim.tmlenet(datO = datO, NetInd_mat = NetInd_mat, 
                                def_sW = def_sW, def_sA = def_sA, Kmax = Kmax,
                                Qform = Qform.mis, f.gstar = f.gstar, psi0 = psi0)


  # datO_input <- datO[,c("W1", "W2", "W3", "sA", "Y")]
  # head(def_sW$get.mat.sVar(data.df = datO_input, netind_cl = netind_cl))
  # head(def_sA$get.mat.sVar(data.df = datO_input, netind_cl = netind_cl))
  # system.time(
  # res <- tmlenet(data = datO_input, Anode = "sA", Wnodes = c("W1", "W2", "W3"), Ynode = "Y",
  #                 Kmax = Kmax,
  #                 NETIDs_mat = NetInd_mat,
  #                 # nFnode = NULL,
  #                 f_gstar1 = f.gstar,
  #                 sW = def_sW, sA = def_sA,
  #                 # Qform = Qform,
  #                 # correct Q:
  #                 # Qform = "Y ~ W1 + W2 + W3 + sA + net.mean.sA",
  #                 # misspecified Q:
  #                 Qform = "Y ~ W2 + W3 + net.mean.sA",
  #                 hform = "sA + net.mean.sA ~ W1 + W2 + W3",
  #                 hform.gstar = "sA + net.mean.sA ~ W1 + W2 + W3",
  #                 gform = "sA ~ W1 + W2 + W3",
  #                 optPars = list(
  #                   # f_g0 = f.A, # tested, works
  #                   n_MCsims = 10)
  #                 )
  # )

  # N=5K w/ 10 MCsim, wrong Q:
  # [1] "new MC.ests mat: "
  #              estimate
  # tmle_A      0.0000000
  # tmle_B      0.2332392
  # tmle_g_iptw 0.0000000
  # h_iptw      0.2542337
  # g_iptw      0.0000000
  # mle         0.2548224
  #    user  system elapsed 
  #   9.599   3.514  12.789

  # N=5K w/ 25 MCsim, correct Q:
  #              estimate
  # tmle_A      0.0000000
  # tmle_B      0.2055218
  # tmle_g_iptw 0.0000000
  # h_iptw      0.2160300
  # g_iptw      0.0000000
  # mle         0.2076507
  #    user  system elapsed 
  #  14.550   5.482  19.527 

  # N=5K w/ 50 MCsim, correct Q:
  # [1] "new MC.ests mat: "
  #              estimate
  # tmle_A      0.0000000
  # tmle_B      0.2063659
  # tmle_g_iptw 0.0000000
  # h_iptw      0.2168128
  # g_iptw      0.0000000
  # mle         0.2073506
  #    user  system elapsed 
  #  35.098  13.188  50.400 

}