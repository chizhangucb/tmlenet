
`%+%` <- function(a, b) paste0(a, b)
# ---------------------------------------------------------------------------------------------------------
# Test network TMLE fit with continous sA 
# TO DO: COVERAGE NEEDs TO BE EVALUTED COVERAGE CONDITIONAL ON 1 NETWORK!!!! (No network resampling for each simulation)
# ---------------------------------------------------------------------------------------------------------
# TMLE for causal effect in network data with continuous exposure under continuous stochastic intervention;
# intervention g.star is defined by shifting the normal density of observed sA until g.star/g.0 >= 10,
# then its truncated to be equal to g.0

run.net.1sim.tmlenet <- function(datO, NetInd_mat, def_sW, def_sA, Kmax, Qform, f.gstar, psi0) {
  datO_input <- datO[,c("W1", "W2", "W3", "sA", "Y")]
  res <- tmlenet(data = datO_input, Anode = "sA", Wnodes = c("W1", "W2", "W3"), Ynode = "Y",
                  Kmax = Kmax,
                  NETIDs_mat = NetInd_mat,
                  # nFnode = NULL,
                  f_gstar1 = f.gstar,
                  sW = def_sW, sA = def_sA,
                  Qform = Qform,
                  hform = "sA + net.mean.sA ~ W1 + W2 + W3",
                  hform.gstar = "sA + net.mean.sA ~ W1 + W2 + W3",
                  gform = "sA ~ W1 + W2 + W3",
                  optPars = list(
                    # f_g0 = f.A, # tested, works
                    n_MCsims = 10)
                  )
                  # correct Q:
                  # Qform = "Y ~ W1 + W2 + W3 + sA + net.mean.sA",
                  # misspecified Q:
                  # Qform = "Y ~ W2 + W3 + net.mean.sA",

  CIs <- res$EY_gstar1$CIs
  print("CIs: "); print(CIs)
  (tmle_B.CI <- CIs[rownames(CIs)%in%"tmle_B",])
  (h_iptw.CI <- CIs[rownames(CIs)%in%"h_iptw",])
  cover.tmle_B <- ((psi0 <= tmle_B.CI[2]) && (psi0 >= tmle_B.CI[1]))
  cover.h_iptw <- ((psi0 <= h_iptw.CI[2]) && (psi0 >= h_iptw.CI[1]))

  est_mat <- res$EY_gstar1$estimates
  est <- as.vector(est_mat)
  names(est) <- rownames(est_mat)
  cover <- apply(CIs, 1, function(row) ((psi0 <= row[2]) && (psi0 >= row[1])))
  cover2 <- c(tmle_B = cover.tmle_B, h_iptw = cover.h_iptw)

  return(list(est = est, cover = cover))
}


# Run one TMLE simulation for network data generated igraph::sample_k_regular (all nodes have the same degree k)
# estimate psi0 under trunced g.star (same as in iid)
# sA is the same as in iid example w sAnet=(sA, rowMeans(sA[[1:Kmax]])).
# TO TRY: Generate network using current gennetwork, simpler gennetwork that samples from uniform and network generated by igraph
# Used for Verifying: 1) consistency, 2) double robustness, 3) correct as. coverage
test.onesim.net.tmlefit <- function() {
  library(simcausal)
  library(tmlenet)
  #------------------------------------------------------------------------------------------------------------
  # The user-defined network sampler(s) from igraph (regular graph model)
  # Generate regular random graphs with same degree for each node
  # Kmax - degree of each node
  generate.igraph.k.regular <- function(n, Kmax, ...) {
    if (n < 20) Kmax <- 5
    igraph.reg <- igraph::sample_k_regular(no.of.nodes = n, k = Kmax, directed = TRUE, multiple = FALSE)
    # From igraph object to sparse adj. matrix:
    sparse_AdjMat <- simcausal::igraph.to.sparseAdjMat(igraph.reg)
    # From igraph object to simcausal/tmlenet input (NetInd_k, nF, Kmax):
    NetInd_out <- simcausal::sparseAdjMat.to.NetInd(sparse_AdjMat)
    print("old Kmax:" %+% Kmax)
    print("new Kmax:" %+% NetInd_out$Kmax)
    print("NetInd_k"); print(head(NetInd_out$NetInd_k))
    if (Kmax < NetInd_out$Kmax) message("new network has larger Kmax value than requested, new Kmax = " %+% NetInd_out$Kmax)
    return(NetInd_out$NetInd_k)
  }
  # graph <- igraph::sample_k_regular(no.of.nodes = 50, k = 10, directed = TRUE, multiple = FALSE)
  # par(mar=c(.1,.1,.1,.1))
  # igraph::plot.igraph(graph,
  #     layout=igraph::layout.fruchterman.reingold,
  #     vertex.size=7,
  #     vertex.label.cex=.5,
  #     edge.arrow.size=.5)

  Kmax <- 10
  trunc.c <- 10
  shift <- 2

  D <- DAG.empty()
  # Adding the ER model network generator from igraph:
  D <- D + network("NetInd_k", Kmax = Kmax, netfun = "generate.igraph.k.regular")
  D <- D +
      node("W1", distr = "rbern", prob = 0.5) +
      node("W2", distr = "rbern", prob = 0.3) +
      node("W3", distr = "rbern", prob = 0.3) +
      node("sA.mu", distr = "rconst", const = (0.98 * W1 + 0.58 * W2 + 0.33 * W3)) +
      # node("shift",  distr = "rconst", const = .(shift)) +
      node("sA", distr = "rnorm", mean = sA.mu, sd = 1) +
      node("net.mean.sA", distr = "rconst", const = mean(sA[[1:Kmax]])) +
      node("r.obs.sA",  distr = "rconst", const = exp(shift * (sA - sA.mu - shift / 2))) +
      # node("trunc.c",  distr = "rconst", const = .(trunc.c)) +
      node("untrunc.sA.gstar",  distr = "rconst", const = sA + shift) +
      # node("untrunc.sA.gstar",  distr = "rnorm", mean = sA.mu + shift, sd = 1) +
      # node("p.gstar.sA", distr = "rconst", const = (1/sqrt(2*.(pi))) * exp((-1/2) * (untrunc.sA.gstar - sA.mu)^2)) +
      # node("p.gstar.sA.gstar", distr = "rconst", const = (1/sqrt(2*.(pi))) * exp((-1/2) * (untrunc.sA.gstar - (sA.mu + shift))^2)) +
      node("r.new.sA",  distr = "rconst", const = exp(shift * (untrunc.sA.gstar - sA.mu - shift / 2))) +
      node("tr.sA.gstar",  distr = "rconst", const = ifelse(r.new.sA > trunc.c, sA, untrunc.sA.gstar)) +
      node("probY", distr = "rconst", const = plogis(-0.35 * sA - 0.20 * mean(sA[[1:Kmax]]) - 0.5 * W1 - 0.58 * W2 - 0.33 * W3)) +
      # node("probY", distr = "rconst", const = plogis(-0.35 * sA - 0.20 * sum(sA[[1:Kmax]]) / nF - 0.5 * W1 - 0.58 * W2 - 0.33 * W3)) +
      node("Y", distr = "rbern", prob = probY) +
      node("probY.gstar", distr = "rconst", const = plogis(-0.35 * tr.sA.gstar - 0.20 * mean(tr.sA.gstar[[1:Kmax]]) - 0.5 * W1 - 0.58 * W2 - 0.33 * W3)) +
      # node("probY.gstar", distr = "rconst", const = plogis(-0.35 * tr.sA.gstar - 0.20 * sum(tr.sA.gstar[[1:Kmax]]) / nF - 0.5 * W1 - 0.58 * W2 - 0.33 * W3)) +
      node("Y.gstar", distr = "rbern", prob = probY.gstar)
  Dset <- set.DAG(D)
  # plotDAG(Dset)
  rndseed2 <- 54321
  nsamp <- 50000
  t1 <- system.time(
    datFull <- sim(Dset, n = nsamp, rndseed = rndseed2)
  )
  t1
  # user  system elapsed  # for 40K with Kmax=10
  # 13.298   0.119  13.375
  # user  system elapsed  # for 50K with Kmax=10
  # 20.377   0.141  20.447
  print(head(datFull, 50))
  # netind_cl <- attributes(datFull)$netind_cl # to get the network object from sim data:
  # NetInd_mat <- attributes(datFull)$netind_cl$NetInd # to get the network matrix from sim data:

  print("mean(datFull$Y): " %+% mean(datFull$Y)); # [1] "mean(datFull$Y): 0.301425"
  psi0 <- mean(datFull$Y.gstar)
  print("psi0: " %+% psi0) # [1] "psi0: 0.19184" for 50K sample

  # Stochastic intervention of interest, returns a vector of new treatment assignments sampled from shifted normal
  f.gstar <- function(data, ...) {
    sA.mu <- 0.98 * data[,"W1"] + 0.58 * data[,"W2"] + 0.33 * data[,"W3"]
    sA <- data[,"sA"]
    # ratio of P_g^*(sA=sa|W)/P_g0(sA=sa|W) for observed sa=sA generated under g0:
    # r.obs.sA <- exp(shift * (sA - sA.mu - shift / 2))
    untrunc.sA.gstar <- sA + shift
    # untrunc.sA.gstar <- rnorm(n = nrow(data), mean = sA.mu + shift, sd = 1)
    # ratio of P_g^*(sA=sa|W)/P_g0(sA=sa|W) for sa=sA generated under g^*:
    r.new.sA <- exp(shift * (untrunc.sA.gstar - sA.mu - shift / 2))
    trunc.sA.gstar <- ifelse(r.new.sA > trunc.c, sA, untrunc.sA.gstar)
    return(trunc.sA.gstar)
  }

  def_sW <- def.sW(W1 = "W1", W2 = "W2", W3 = "W3")
  # NEED TO BE REPLACED WITH A MEAN sA ONLY AMONG EXISTING FRIENDS: sum(sA[[1:Kmax]]/nF)
  def_sA <- def.sA(sA = "sA", net.mean.sA = rowMeans(sA[[1:Kmax]]), replaceNAw0 = TRUE)
  Qform.corr <- "Y ~ W1 + W2 + W3 + sA + net.mean.sA" # # correct Q:
  # Qform.mis <- "Y ~ W3 + sA" # # misspecified Q:
  Qform.mis <- "Y ~ W2 + W3 + net.mean.sA" # # misspecified Q:
  Qforms <- c(Qform.corr = Qform.corr, Qform.mis = Qform.mis)

  # res <- run.net.1sim.tmlenet(datO, NetInd_mat, Kmax = Kmax, nsamp, Qform, f.gstar, trunc.c = 10, shift = 2)
  rndseed <- 12345
  # datO <- sim(Dset, n = 5000)
  # datO <- sim(Dset, n = 5000, rndseed = rndseed)
  # datO <- sim(Dset, n = 10000, rndseed = rndseed)
  datO <- sim(Dset, n = 10000)

  system.time(
    datO <- sim(Dset, n = 40000)
  )
  #   user  system elapsed
  # 12.827   0.127  12.816

  netind_cl <- attributes(datO)$netind_cl
  NetInd_mat <- attributes(datO)$netind_cl$NetInd
  dim(NetInd_mat)

  getOption("tmlenet.verbose")
  options(tmlenet.verbose = TRUE)
  print_tmlenet_opts()
  # to pool by contin outcome:
  # tmlenet_options(poolContinVar = TRUE, useglm = FALSE)
  tmlenet_options(maxNperBin=5000)
  # tmlenet_options(binByMass = FALSE, useglm = TRUE)
  system.time(
    simres <- run.net.1sim.tmlenet(datO = datO, NetInd_mat = NetInd_mat,
                                    def_sW = def_sW, def_sA = def_sA, Kmax = Kmax,
                                    Qform = Qform.mis, f.gstar = f.gstar, psi0 = psi0)
  )

  # TO INSPECT THE SUMMARY MEASURES DIRECTLY
  datO_input <- datO[,c("W1", "W2", "W3", "sA", "Y")]
  head(def_sW$get.mat.sVar(data.df = datO_input, netind_cl = netind_cl))
  head(def_sA$get.mat.sVar(data.df = datO_input, netind_cl = netind_cl))

  # N=5K w/ 10 MCsim, wrong Q, rndseed <- 12345
  # h est with full factorization
  # [1] "new MC.ests mat: "
  #              estimate
  # tmle_A      0.0000000
  # tmle_B      0.2119040
  # tmle_g_iptw 0.0000000
  # h_iptw      0.2176838
  # g_iptw      0.0000000
  # mle         0.2803595
  # [1] "CIs: "
  #             LBCI_0.025 UBCI_0.975
  # tmle_A       0.0000000  0.0000000
  # tmle_B       0.1384394  0.2853686
  # tmle_g_iptw  0.0000000  0.0000000
  # h_iptw       0.1313935  0.3039742
  # g_iptw       0.0000000  0.0000000
  # mle          0.2803595  0.2803595

  # N=5K w/ 10 MCsim, wrong Q, rndseed <- 12345:
  # h est by pooling across bins
  #   [1] "new MC.ests mat: "
  #              estimate
  # tmle_A      0.0000000
  # tmle_B      0.2028481
  # tmle_g_iptw 0.0000000
  # h_iptw      0.1962709
  # g_iptw      0.0000000
  # mle         0.2803625
  # [1] "CIs: "
  #             LBCI_0.025 UBCI_0.975
  # tmle_A       0.0000000  0.0000000
  # tmle_B       0.1270191  0.2786772
  # tmle_g_iptw  0.0000000  0.0000000
  # h_iptw       0.1153495  0.2771923
  # g_iptw       0.0000000  0.0000000
  # mle          0.2803625  0.2803625

  # N=5K w/ 10 MCsim, wrong Q, another random seed:
  # [1] "new MC.ests mat: "
  #              estimate
  # tmle_A      0.0000000
  # tmle_B      0.2332392
  # tmle_g_iptw 0.0000000
  # h_iptw      0.2542337
  # g_iptw      0.0000000
  # mle         0.2548224
  #    user  system elapsed
  #   9.599   3.514  12.789
  # N=5K w/ 25 MCsim, correct Q:
  #              estimate
  # tmle_A      0.0000000
  # tmle_B      0.2055218
  # tmle_g_iptw 0.0000000
  # h_iptw      0.2160300
  # g_iptw      0.0000000
  # mle         0.2076507
  #    user  system elapsed
  #  14.550   5.482  19.527
  # N=5K w/ 50 MCsim, correct Q:
  # [1] "new MC.ests mat: "
  #              estimate
  # tmle_A      0.0000000
  # tmle_B      0.2063659
  # tmle_g_iptw 0.0000000
  # h_iptw      0.2168128
  # g_iptw      0.0000000
  # mle         0.2073506
  #    user  system elapsed
  #  35.098  13.188  50.400

}