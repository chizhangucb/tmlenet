% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/SummariesModel_class.R
\docType{class}
\name{RegressionClass}
\alias{RegressionClass}
\title{R6 class that defines regression models evaluating P(sA|sW), for summary measures (sW,sA)}
\format{An \code{\link{R6Class}} generator object}
\usage{
RegressionClass
}
\description{
This R6 class defines fields and methods for defining all the parameters that control the non-parametric
 modelling and estimation of multivariate joint conditional probability model P(sA|sW) for summary measures (sA,sW).
 Note that sA can be multivariate and any component of sA[j] can be either binary, categorical or continuous.
 The joint probability for P(sA|sA) = P(sA[1],...,sA[k]|sA) is first factorized as
 P(sA[1]|sA) * P(sA[2]|sA, sA[1]) * ... * P(sA[k]|sA, sA[1],...,sA[k-1]),
 where each of these conditional probability models is defined by a new instance of a SummariesModel class
 (and the corresponding instance of a RegressionClass class).
 If sA[j] is binary, the conditional probability for P(sA[j]|sW,sA[1],...,sA[j-1]) is evaluated via logistic regression model.
 When sA[j] is categorical or continuous, its estimation will be controlled with a new instance of
 the ContinSummaryModel class (and the accompanying instance of a RegressionClass class), which first partitions the range of
 continuous/categorical sA[j] into K bins and corresponding K bin indicators (B_1,...,B_K) and then instantiates K new
 SummariesModel classes (with their corresponding RegressionClass classes), where each of these K classes now defines a
 single logistic regression model with binary bin indicator outcome B_j and predictors (sW, sA[1],...,sA[k-1]).
 Thus, the first instance of RegressionClass and SummariesModel classes will automatically
 spawn recursive calls to new instances of these classes until the entire tree of binary logistic regressions that defines
 the joint probability P(sA|sW) is build.
}
\details{
\itemize{
\item{NetInd_k} - Matrix of friend indices (network IDs) of \code{dim = (nobs x Kmax)}.
\item{nF} - Vector of integers, where \code{nF[i]} is the integer number of friends (0 to \code{Kmax}) for observation \code{i}.
\item{nobs} - Number of observations
\item{Kmax} - Maximum number of friends for any observation.
}
}
\section{Methods}{

\describe{
  \item{\code{new(nobs, Kmax = 1)}}{Uses \code{nobs} and \code{Kmax} to instantiate an object of R6 class and pre-allocate memory
         for the future network ID matrix.}
  \item{\code{makeNetInd.fromIDs(Net_str, IDs_str = NULL, sep = ' ')}}{Build the matrix of network IDs (\code{NetInd_k}) from IDs string vector,
         all friends of one observation \code{i} are located in a string Net_str[i], with two distinct friend IDs of \code{i}
         separated by character \code{sep}. If \code{IDs_str} is NULL it is assumed that the friends in Net_str are
         actual row numbers in \code{1:nobs}, otherwise IDs from Net_str will be used for looking up the observation row numbers in \code{IDs_str}.}
  \item{\code{make.nF(NetInd_k = self$NetInd_k, nobs = self$nobs, Kmax = self$Kmax)}}{This method calculates the integer number of
        friends for each row of the network ID matrix (\code{self$NetInd_k}). The result is assigned to a field \code{self$nF} and
        is returned invisibly.}
  \item{\code{mat.nF(nFnode)}}{\code{nFnode} - the character name for the number of friends variable that is assigned as a column
  name to a single column matrix in \code{self$nF}.}
}
}
\keyword{R6}
\keyword{class}

