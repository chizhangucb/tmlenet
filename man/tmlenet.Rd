% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/tmlenet.R
\name{tmlenet}
\alias{tmlenet}
\title{Estimate Average Network Effects Under Arbitrary (Stochastic) Interventions}
\usage{
tmlenet(data, Kmax, Anode, AnodeDET = NULL, Wnodes, Ynode, YnodeDET = NULL,
  nFnode = "nF", IDnode = NULL, NETIDs_str = NULL, f_gstar1,
  f_gstar2 = NULL, sW = NULL, sA = NULL, Qform = NULL, hform = NULL,
  hform.gstar = NULL, gform = NULL, Qform.depr = NULL,
  gform.depr = NULL, hform.depr = NULL, verbose = FALSE,
  args_f_g1star = NULL, args_f_g2star = NULL, optPars = list(alpha = 0.05,
  gbound = 0.005, family = "binomial", n_MCsims = ceiling(sqrt(nrow(data))),
  onlyTMLE_B = TRUE, f_g0 = NULL))
}
\arguments{
\item{data}{Input observed data as a \code{data.frame}, with named columns for baseline covariates (W), assigned treatment (A), the outcome (Y) and network of friends (F)}

\item{Kmax}{Absolute maximum number of friends (connected units) for any observation in the input \code{data}}

\item{Anode}{Treatment variable name (column name in \code{data}), can be either binary, categorical or continous}

\item{AnodeDET}{(Optional) Column name for indicators of deterministic values of A, coded as (TRUE/FALSE) or (1/0), the observations with AnodeDET=TRUE/1 are assumed to have constant value for their Anode}

\item{Wnodes}{Vector of baseline covariate names (column names in \code{data})}

\item{Ynode}{Outcome variable name (column name in \code{data}), assumed normalized 0 to 1}

\item{YnodeDET}{(Optional) Column name for indicators of deterministic values of Y, coded as (TRUE/FALSE) or (1/0), the observations with YnodeDET=TRUE/1 are assumed to have constant value for their Ynode}

\item{nFnode}{(Optional) Name of the variable for the number of friends each unit has, this name can then be used inside the summary measures and regression formulas \code{sW}, \code{sA}, \code{Qform}, \code{hform}, \code{hform.gstar} and \code{gform}. See Details.}

\item{IDnode}{(Optional) Subject identifier variable in the input data, if not supplied the network string in NETIDs_str is assumed to be indexing the row numbers in the input \code{data}}

\item{NETIDs_str}{(Optional) Column name in data consisting of strings that identify the unit's friends by their IDs or their row numbers (two friends are separated by space, e.g., "1 2"; unit with no friends should have an empty "" string). See Details.}

\item{f_gstar1}{Function for specifying an intervention of interest that can be static, dynamic treatment regimen or stochastic intervention. See Details.}

\item{f_gstar2}{(Optional) Function for specifying another intervention of interest when estimating the treatment effects under two interventions}

\item{sW}{Summary measures constructed from variables in \code{Wnodes}. This must be an object of class \code{Define_sVar} that is returned by calling the function \code{\link{def.sW}}. (NOT IMPLEMENTED: See Details for default sW when it is left missing)}

\item{sA}{Summary measures constructed from variables in \code{Anode} and \code{Wnodes}. This must be an object of class \code{Define_sVar} that is returned by calling the function \code{\link{def.sW}}. (NOT IMPLEMENTED: See Details for default sA when its missing)}

\item{Qform}{(Optional) Regression formula for outcome in Ynode, when NULL (default) Ynode is regressed on all variables defined in \code{sW} and \code{sA}. See Details.}

\item{hform}{(Optional) Regression formula for estimating the conditional probability of P(sA | sW) under gN (observed treatment mechanism), when NULL (default) sA includes all variables in \code{sA} argument and sW includes all variables in \code{sW}. See Details.}

\item{hform.gstar}{(Optional) Regression formula for estimating the conditional probability P(sA | sW) under gstar, when NULL (default) the same regression formula as in hform will be used. See Details.}

\item{gform}{(Optional) Regression formula for the joint treatment mechanism, g, that includes the product of all friends treatments, P(A_i, A_{F_i} | W). See Details.}

\item{Qform.depr}{(DEPRECATED)}

\item{gform.depr}{(DEPRECATED)}

\item{hform.depr}{(DEPRECATED)}

\item{verbose}{(NOT IMPLEMENTED) Flag for controlling printing of additional messages}

\item{args_f_g1star}{(Optional) Additional arguments to be passed to \code{f_gstar1} intervention function}

\item{args_f_g2star}{(Optional) Additional arguments to be passed to \code{f_gstar2} intervention function}

\item{optPars}{(Optional) A named list of additional parameters to be passed to \code{tmlenet}, such as alpha, gbound, family, n_MCsims, onlyTMLE_B, f_g0. See Details.}

\item{NETIDs_mat}{(Optional / NOT IMPLEMENTED) Matrix (\code{ncol=Kmax}, \code{nrow=nrow(data)}), where each row \code{i} is a vector of \code{i}'s friends IDs or \code{i}'s friends row numbers in \code{data} if \code{IDnode=NULL}. See Details.}
}
\value{
A named list of the target parameter estimates of the population mean under intervention \code{f_gstar1} (EY_gstar1), their asymptotic variance estimates and CI estimates at \code{alpha} level.
If \code{f_gstar2} was also specified, the list will consists of the three sets of estimates,
the first for the target parameter estimates under \code{f_gstar1} (EY_gstar1), the second for estimates under \code{f_gstar2} (EY_gstar2) and
the third for the estimates of the additive treatment effect (EY_gstar1 - EY_gstar2) under intervention in \code{f_gstar1} vs. intervention in \code{f_gstar2}.

Currently available estimators are:
\itemize{
\item \code{\link{tmle_A}} - Covariate-based efficient TMLE using covariate h_gstar/h_gN.
\item \code{\link{tmle_B}} - Intercept-based efficient TMLE using weights h_gstar/h_gN.
\item \code{\link{tmle_g_iptw}} - Covariate-based more non-parametric TMLE using covariate gN/gstar.
\item \code{\link{h_iptw}} - Efficient IPTW based on weights h_gstar/h_gN.
\item \code{\link{g_iptw}} - More non-parametric IPTW based on weights gN/gstar.
\item \code{\link{mle}} - Parametric G-computation-based substitution estimator.
}
}
\description{
Estimate the average network effect among dependent units with known network structure (in the presence of interference and/or spillover)
with a variety of estimation procedures: \emph{TMLE} (Targeted Minimum Loss-Based Estimation), \emph{IPTW} (Inverse Probability Weighted) and \emph{MLE} (parametric G-computation formula).
}
\section{Details}{


(NOT IMPLEMENTED) When \code{sW} is missing, by default \code{sW} is constructed as follows.
For each \code{"W"} in \code{Wnodes}, add a vector \code{data[,"W"]} as well as all friends covariate values of \code{"W"} to \code{sW} by running \code{netW = def.sW(W[[0:Kmax]], noname = TRUE)}.
For each \code{"W"} in \code{Wnode}, a vector of \code{"W"} values of the first friend of observations \code{i} = 1,...,\code{nrow(data)} will be created and named \code{"W_netF1"}
(i.e., variable "W_netF1" is constructed as def.sW(W_netF1 = W[[1]])).
Similarly, the vector of "W" values of the jth friend for observations \code{i} = 1, ..., \code{nrow(data)} will be created and named "W_netFj", for j from 1 to \code{Kmax}, with all \code{W_netFj} then being added to \code{sW}.

(NOT IMPLEMENTED) Similarly, when \code{sA} is missing, it is constructed by running \code{def.sW(netA = A[[0:Kmax]], noname = TRUE)} (assuming \code{"A"} is the value of \code{Anode} in \code{data}),
which combines the column \code{data[,"A"]} with all the friends treatment assignments of variable "A".

Note that when observation \code{i} has only \code{j-1} friends, the i's value of \code{"W_netFj"} is automatically set to \code{NA}.
This can be an undersirable behavior in some circumstances, in which case one can automatically replace all such \code{NA}'s with \code{0}'s by setting the argument \code{replaceMisVal0 = TRUE} when calling function \code{def.sW},
i.e., \code{def.sW(W_netF1 = W[[1]], replaceMisVal0 = TRUE)}.

When \code{NETIDs_str} or \code{NETIDs_mat} are left unspecified, the input data is assumed independent, with no network structure. All inference will be performed based on the iid efficient influence curve for the target parameter (EY_gstar1).
Note that the ordering of the friends in \code{NETIDs_str} or \code{NETIDs_mat} is unimportant.

The number of friends (\code{nFnode}) is calculate automatically. However, if the column \code{data[,nFnode]} already exists in the input data
it will be compared to the automatically calculated values, with an error produced if the two variables do not exactly match.

The formalas in \code{Qform}, \code{hform}, \code{hform.gstar}, \code{gform} can include any summary measures defined in sW and sA,
referenced by their individual variable names or by their aggregate summary measure names.
For example, \code{hform = "netA ~ netW"} is equivalent to \code{hform = "A + A_netF1 + A_netF2 ~ W + W_netF1 + W_netF2"}
for \code{sW,sA} summary measuresÂ defined by \code{def.sW(netW=W[[0:2]], noname=TRUE)} and \code{def.sA(netA=A[[0:2]], noname=TRUE)}.

The functions \code{f_gstar1} and \code{f_gstar2} can only depend on variables specified in the summary measures \code{sW},
the functions have to return a vector of length \code{nrow(data)} that represent the counterfactual treatment assignments for observations in the input data.

Additional optional parameters that can be passed inside a named list \code{optPars} include:
\itemize{
\item \code{alpha} - alpha-level for CI calculation (0.05 for 95% CIs);
\item \code{gbound} - One value for symmetrical bounds on g(A | W) and P(sW | sW), or a vector of length 2 specifying upper and lower bounds.
\item \code{n_MCsims} - Number of Monte-Carlo simulations to perform when evaluating P(sA | sW) under gstar and f_g0 (if specified) and while evaluating the target parameter estimator under gstar;
\item \code{family} - Family specification for regression models, defaults to binomial. CURRENTLY ONLY BINOMIAL FAMILY IS IMPLEMENTED.
\item \code{onlyTMLE_B} - When \code{TRUE}, only one of the 3 TMLE estimators is evaluated, tmle_B, which is the intercept-based TMLE (no clever covariate, h_gN / h_gstar is used as weights in parametric model fluctuation).
\item \code{f_g0} - A function for generating true treatment mechanism A, when it is known (for example in a randomized trial). Used only when estimating P(sA | sW) under g0 by sampling large vector of A (of length n*n_MCsims) from \code{f_g0};
}
}

\section{Specifying the Network of Friends}{


The network of friends (connections) for observations in the input \code{data} can be specified in two alternative ways,
using either \code{NETIDs_str} or \code{NETIDs_mat} input arguments.

\code{NETIDs_str} - The first (slower) method uses a vector of strings in \code{data[, NETIDs_str]}, where each string \code{i} must contain
the space separated IDs or row numbers of all units in \code{data} thought to be connected to observation i (friends of unit i);

\code{NETIDs_mat} - (NOT IMPLEMENTED) An alternative (faster) way is to pass a matrix with \code{Kmax} columns and nrow(data) rows,
where each row \code{NETIDs_mat[i,]} is a vector of observation \code{i}'s friends' IDs or \code{i}'s friends' row numbers in \code{data} if \code{IDnode=NULL}.
If observation \code{i} has fewer than \code{Kmax} friends, the remainder of \code{NETIDs_mat[i,]} must be filled with \code{NA}s.
Note that the ordering of friend indices is irrelevant.
}
\examples{
rm(list=ls())

#------------------------------------
# Packages / package functions used so far inside tmlenet.
# If you are using just a few functions from another package, my recommendation is to note the package name in the Imports: field of the DESCRIPTION
# file and call the function(s) explicitly using ::, e.g., pkg::fun().

# If you are using functions repeatedly, you can avoid :: by importing the function with @importFrom pgk fun. 
# This also has a small performance benefit, because :: adds approximately 5 Âµs to function evaluation time.

# Alternatively, if you are repeatedly using many functions from another package, you can import all of them using @import package.
# This is the least recommended solution because it makes your code harder to read (you canât tell where a function is coming from), 
# and if you @import many packages, it increases the chance of conflicting function names.

#-----------------------------------
# ADD tmlenet SOURCE CODE
library(R6)
library(assertthat)
options(echo = TRUE)
options(width = 160)

library(devtools)
load_all("../") # load all R files in /R and datasets in /data. Ignores NAMESPACE:

#--------------------------------------------------------
# NOTE: arguments n_MCsims and n_samp_g0gstar specify the number of Monte-Carlo sims tmlenet needs to run
# if things are taking too long try lower numbers (esspecially for n_MCsims)
#--------------------------------------------------------

# Set x\% of community to A=1 (returns probability P(A=1))
f.A_x <- function(data, x, ...) rep(x, nrow(data))
# Deterministically set every A=0
f.A_0 <- function(data, ...) f.A_x(data, 0, ...)
# Deterministically set every A=1
f.A_1 <- function(data, ...) f.A_x(data, 1, ...)

#***************************************************************************************
# EXAMPLE WITH SIMULATED DATA FOR 6 FRIENDS AND 3 W's (SIMULATION 3)
#***************************************************************************************
# library(tmle)
library(locfit)
library(xtable)
library(bigmemory)
library(biganalytics)
library(plyr)
options(bigmemory.typecast.warning=FALSE)

kmax <- 6	# Max # of friends (K)?
# simulate a dataset first
source("../datgen_nets/sim3_datgen_k6.R")
set.seed(543)
n <- 1000
# df_K6 <-gendata_pop(nC=1, n_arr=1000, k_arr=kmax, EC_arr=EC, f.g_list="f.A", f.g_args_list=list(NULL))
t <- system.time(df_K6 <- gendata_pop(nC=1, n_arr=n, k_arr=kmax, EC_arr=EC, f.g_list="f.A", f.g_args_list=list(NULL)))
t
# for n=10K:
#   user  system elapsed 
# 33.117   0.976  33.898 

head(df_K6)
  # IDs Y nFriends W1 W2 W3 netW1_sum netW2_sum netW3_sum A                  Net_str
# 1  I1 1        1  3  0  1         2         1         0 1                     I537
# 2  I2 1        5  3  1  0        16         4         3 0    I6 I58 I595 I641 I654
# 3  I3 0        5  5  0  0        18         3         3 0 I163 I637 I650 I722 I783
# 4  I4 1        2  2  1  0         6         1         0 1                 I49 I995
# 5  I5 1        3  3  1  1        11         3         1 0           I358 I369 I762
# 6  I6 1        2  2  0  1         6         2         0 1                I682 I917

class(df_K6$A) # [1] "integer"
class(df_K6$nFriends) # [1] "numeric"
table(df_K6$W1)
 #   0    1    2    3    4    5 
 # 475 1772 2900 2615 1718  520 
c(mean(df_K6$W1), mean(df_K6$W2), mean(df_K6$W3))
# [1] 2.4889 0.5719 0.6031

mean(df_K6$A) # [1] 0.198
mean(df_K6$Y) # [1] 0.435
mean(df_K6$nFriends) # [1] 3.307

# --------------------------------------------------
# # NEW INTERFACE FOR SPECIFYING hform, Qform, gform allows including the summary measure names
# --------------------------------------------------
# testform1 <- as.formula("sA + sA2 ~ sW1 + netW3_sum")
# testform2 <- as.formula("netA ~ netW2 + netW3_sum")
# testform <- testform1
# testterms <- terms(testform)
# # Getting predictor sW names:
# (sW.names <- attributes(testterms)$term.labels)
# sW.names.alt <- colnames(attributes(testterms)$factors)
# assert_that(all(sW.names == sW.names.alt))
# # Getting outcome sA names:
# (out.var <- rownames(attributes(testterms)$factors)[1]) # character string
# out.vars.form <- as.formula(". ~ " \%+\% out.var)
# out.vars.terms <- terms(out.vars.form)
# (sA.names <- attributes(out.vars.terms)$term.labels)

# --------------------------------------------------
# SUMMARY MEASURES
# --------------------------------------------------
# NOT WRITTEN YET. Will evaluate the summary measures applied to the (O)bserved data (data.frame):
# res <- eval.summaries(summaries = def_sA, Odata = df_K6, Kmax = kmax, NETIDnode = "Net_str", IDnode = "IDs")

#----------------------------------------------------------------------------------
# Example 1. Mean population outcome under deterministic intervention A=0 with 6 friends
# CAN RETIRE Qform, gform & hform -> fully replaced by summary measures
#----------------------------------------------------------------------------------
Wnodes <- c("W1", "W2", "W3", "netW1_sum", "netW2_sum", "netW3_sum")
head(df_K6)

# #todo 67 (tmlenet) +0: add data checks: 1) test Anode is binary; 2) no missing data among A,W,Y

def_sW <- def.sW(netW2 = W2[[1:Kmax]], noname = TRUE) + 
            def.sW(netW3_sum = rowSums(W3[[1:Kmax]]), replaceNAw0 = TRUE)
            
def_sA <- def.sA(sum_1mAW2_nets = rowSums((1-A[[1:Kmax]]) * W2[[1:Kmax]]), replaceNAw0 = TRUE) +
            def.sA(netA = A[[0:Kmax]], noname = TRUE)

(Qform.depr <- "Y ~ I(" \%+\% paste(str_c(netvar("W2", (1:6)), "*", "(1-",netvar("A", (1:6)), ")"), collapse = "+") \%+\% ")" \%+\% "+"  \%+\% "netW3_sum")
(gform.depr <- "A ~  W1 + netW1_sum + netW2_sum + netW3_sum + nFriends")
(hform.depr <- "sA ~ " \%+\% paste(netvar("W2", (1:6)), collapse = "+") \%+\% " + netW3_sum + nFriends")

system.time(
tmlenet_K6out2 <- tmlenet(data = df_K6, Anode = "A", Wnodes = Wnodes, Ynode = "Y", nFnode = "nFriends",
                          Kmax = kmax, 
                          IDnode = "IDs", 
                          NETIDnode = "Net_str",
                          # NETIDnode = NULL,
                          f_gstar1 = f.A_0,

                          # OLD regs (TO BE REMOVED):
                          Qform.depr = Qform.depr, hform.depr = hform.depr, #gform.depr = gform.depr,  # remove

                          sW = def_sW, sA = def_sA,
                          # new way to specify regressions:
                          Qform = "Y ~ netW3_sum + sum_1mAW2_nets",
                          hform = "netA ~ netW2 + netW3_sum + nFriends",
                          hform.gstar = "netA ~ netW3_sum",
                          gform = "A ~  W1 + netW1_sum + netW2_sum + netW3_sum + nFriends",
                          opt.params = list(
                            onlyTMLE_B = FALSE,  # remove
                            # f_g0 = f.A, # tested, works
                            n_MCsims = 10
                          )
                          ))
                          # alternative way to pass summary measures:
                          # sW = list("W1[[0]]", "W2[[0:Kmax]]", "W3[[0:Kmax]]", netW1_sum = "rowSums(W1[[1:Kmax]]"), netW2_sum = "rowSums(W2[[1:Kmax]])", netW3_sum = "rowSums(W3[[1:Kmax]])"), 
                          # sA = list("A[[0:Kmax]]", sum_1mAW2_nets = "rowSums((1-A[[1:Kmax]]) * W2[[1:Kmax]]))")

tmlenet_K6out2$EY_gstar1$estimates
tmlenet_K6out2$EY_gstar1$vars
tmlenet_K6out2$EY_gstar1$CIs
tmlenet_K6out2$EY_gstar1$other.vars

# ================================================================
# COMPARING OLD vs NEW OUTPUT
# N=1,000
# ================================================================
# with h method is subsetting (excluding degenerate outcome sA):
                             # old: 	# new:
# epsilon (covariate)      0.02549743 0.02549743
# alpha (intercept)        0.05410938 0.05410938
# iptw epsilon (covariate) 0.03556655 0.03556655

              # old:	# new:
# tmle_A     0.5053725 0.5053725
# tmle_B     0.5051903 0.5051903
# iid.tmle_B 0.4475714 0.4475714
# tmle_iptw  0.5123310 0.5123310
# iptw_h     0.5065960 0.5065960
# iptw       0.4910014 0.4910014
# iid.iptw   0.4429414 0.4429414
# mle        0.4970377 0.4970377
# ================================================================
# NEW INTERFACE FINAL RESULTS WITH MC EVAL (FULL MATCH TO OLD)
# gIPTW and TMLE_gIPTW AREN'T YET IMPLEMENTED
# ================================================================
#                         h_iptw
# epsilon (covariate) 0.02549743
# alpha (intercept)   0.05410938
# [1] "time to run MCS: "
#    user  system elapsed 
#   0.099   0.010   0.109 
#   fWi_init_A   fWi_init_B   fWi_star_A   fWi_star_B 
# -0.008334713 -0.008152518 -0.505372462 -0.505190268 
# [1] "new MC.ests vec: "
#      tmle_A      tmle_B tmle_g_iptw      h_iptw      g_iptw         mle 
#   0.5053725   0.5051903   0.0000000   0.5065960   0.0000000   0.4970377 
# [1] "new MC.ests mat: "
#              estimate
# tmle_A      0.5053725
# tmle_B      0.5051903
# tmle_g_iptw 0.0000000
# h_iptw      0.5065960
# g_iptw      0.0000000
# mle         0.4970377

# ================================================================
# COMPARING OLD vs NEW Vars & CIs:
# ================================================================

# OLD tmle results object:
# > tmlenet_K6out2$EY_gstar1$vars
#                      var
# tmle_A      0.0009265246
# tmle_B      0.0009268804
# tmle_g_iptw 0.0005006418
# h_iptw      0.0021023317
# g_iptw      0.0060034386
# mle         0.0000000000
# > tmlenet_K6out2$EY_gstar1$CIs
#             LBCI_0.025 UBCI_0.975
# tmle_A       0.4457134  0.5650315
# tmle_B       0.4455197  0.5648608
# tmle_g_iptw  0.4698876  0.5575961
# h_iptw       0.4167293  0.5964627
# g_iptw       0.3669720  0.6706953
# mle          0.4970377  0.4970377
# > tmlenet_K6out2$EY_gstar1$other.vars
# var_iid.tmle_B var_tmleiptw_2ndO     var_iptw_2ndO var_tmle_A_Q.init var_tmle_B_Q.init 
#    0.0004350965      0.0003162110      0.0789868609      0.0008532711      0.0008535512 

# NEW CIs:
# gIPTW and TMLE_gIPTW AREN'T YET IMPLEMENTED
# $EY_gstar1$vars
#                      var
# tmle_A      0.0009265246
# tmle_B      0.0009268804
# tmle_g_iptw 0.0069826701
# h_iptw      0.0021023317
# g_iptw      0.0000000000
# mle         0.0000000000
# $EY_gstar1$CIs
#             LBCI_0.025 UBCI_0.975
# tmle_A       0.4457134  0.5650315
# tmle_B       0.4455197  0.5648608
# tmle_g_iptw -0.1637792  0.1637792
# h_iptw       0.4167293  0.5964627
# g_iptw       0.0000000  0.0000000
# mle          0.4970377  0.4970377
# > tmlenet_K6out2$EY_gstar1$other.vars
#    var_iid.tmle_B var_tmleiptw_2ndO     var_iptw_2ndO var_tmle_A_Q.init var_tmle_B_Q.init 
#      0.0004350965      0.0846013137      0.0000000000      0.0008532711      0.0008535512 


#----------------------------------------------------------------------------------
# Example 2. Mean population outcome under deterministic intervention A=1 with 6 friends
#----------------------------------------------------------------------------------
tmlenet_K6out2 <- tmlenet(data=df_K6, Anode="A", Wnodes=Wnodes, Ynode="Y", nFnode="nFriends",
						Kmax=kmax, IDnode="IDs", NETIDnode="Net_str", Qform=Qform, gform=gform, h_form=hform,
						f.g1.star=f.A_1, f.g1_args=NULL, n_MCsims=10, n_samp_g0gstar=10)

tmlenet_K6out2$estimates$EY_g1.star$tmle_B
tmlenet_K6out2$estimates$EY_g1.star$CI_tmle_B_iidIC


#***************************************************************************************
# EXAMPLE WITH SIMULATED DATA FOR 2 FRIENDS AND 1 COVARIATE W1 (SIMULATION 1)
#***************************************************************************************
# data(sample_network_k2)
load(file="./sample_network_k2.RData")
head(sample_network_k2)

#--------------------------------------------------------
# Define regression formulas for Q and g
# ****IMPORTANT****: 
#	use notation netVAR_1 to refer to covariate VAR of the 1st friend
# 	netVAR_2 to refer to covariate VAR of the 2nd friend and so on...
#--------------------------------------------------------
Qform <- "Y ~  W1 + A + netW1_1 + netW1_2 + netA_1 + netA_2 + nFriends"
gform <- "A ~  W1 + netW1_1 + netW1_2 + nFriends"

#----------------------------------------------------------------------------------
# Example 1. Mean population outcome under deterministic intervention A=0
#----------------------------------------------------------------------------------
tmlenet_out1 <- tmlenet(data=sample_network_k2, Anode="A", Wnodes="W1", Ynode="Y", nFnode="nFriends",
						Kmax=2, IDnode="IDs", NETIDnode="Net_str", Qform=Qform, gform=gform, 
						f.g1.star=f.A_0, f.g1_args=NULL)

# TMLE estimate and iid IC-based 95\% CI:
tmlenet_out1$estimates$EY_g1.star$tmle_B
tmlenet_out1$estimates$EY_g1.star$CI_tmle_B_iidIC

# Efficient IPTW (h) and iid IC-based 95\% CI:
tmlenet_out1$estimates$EY_g1.star$iptw_h
tmlenet_out1$estimates$EY_g1.star$CI_iptw_h_iidIC

# Inefficient IPTW (g) + (two CIs, less conservative and more conservative)
tmlenet_out1$estimates$EY_g1.star$iptw
tmlenet_out1$estimates$EY_g1.star$CI_iptw_iidIC_1stO
tmlenet_out1$estimates$EY_g1.star$CI_iptw_iidIC_2ndO

# MLE
tmlenet_out1$estimates$EY_g1.star$mle

#----------------------------------------------------------------------------------
# Example 2. Mean population outcome under stochastic intervention P(A=1)=0.2
#----------------------------------------------------------------------------------
tmlenet_out2 <- tmlenet(data=sample_network_k2, Anode="A", Wnodes="W1", Ynode="Y", nFnode="nFriends",
						Kmax=2, IDnode="IDs", NETIDnode="Net_str", Qform=Qform, gform=gform,
						f.g1.star=f.A_x, f.g1_args=list(x=0.2),
						n_MCsims=4000, n_samp_g0gstar=100)

# TMLE estimate and iid IC-based 95\% CI:
tmlenet_out2$estimates$EY_g1.star$tmle_B
tmlenet_out2$estimates$EY_g1.star$CI_tmle_B_iidIC

# Efficient IPTW (h) and iid IC-based 95\% CI:
tmlenet_out2$estimates$EY_g1.star$iptw_h
tmlenet_out2$estimates$EY_g1.star$CI_iptw_h_iidIC

# Inefficient IPTW (g) + (two CIs, less conservative and more conservative)
tmlenet_out2$estimates$EY_g1.star$iptw
tmlenet_out2$estimates$EY_g1.star$CI_iptw_iidIC_1stO
tmlenet_out2$estimates$EY_g1.star$CI_iptw_iidIC_2ndO

# MLE
tmlenet_out2$estimates$EY_g1.star$mle

#----------------------------------------------------------------------------------
# Example 3. Average treatment effect (ATE) for two interventions, f.g1.star: A=1 vs f.g2.star: A=0
#----------------------------------------------------------------------------------
tmlenet_out3 <- tmlenet(data=sample_network_k2, Anode="A", Wnodes="W1", Ynode="Y", nFnode="nFriends",
						Kmax=2, IDnode="IDs", NETIDnode="Net_str", Qform=Qform, gform=gform,
						f.g1.star=f.A_1, f.g1_args=NULL, f.g2.star=f.A_0, f.g2_args=NULL,
						n_MCsims=4000, n_samp_g0gstar=100)

# TMLE estimate for ATE + 95\% CI
tmlenet_out3$estimates$ATE$tmle_B
tmlenet_out3$estimates$ATE$CI_tmle_B_iidIC

# Efficient IPTW (h) and iid IC-based 95\% CI:
tmlenet_out3$estimates$ATE$iptw_h
tmlenet_out3$estimates$ATE$CI_iptw_h_iidIC

# Inefficient IPTW (g) + (two CIs, less conservative and more conservative)
tmlenet_out3$estimates$ATE$iptw
tmlenet_out3$estimates$ATE$CI_iptw_iidIC_1stO
tmlenet_out3$estimates$ATE$CI_iptw_iidIC_2ndO

# MLE
tmlenet_out3$estimates$ATE$mle





}
\seealso{
\code{\link{def.sW}}
}

