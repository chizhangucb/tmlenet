% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/tmlenet.R
\name{tmlenet}
\alias{tmlenet}
\title{Estimate Average Network Effects For Arbitrary (Stochastic) Interventions}
\usage{
tmlenet(data, Kmax, sW, sA, Anode, AnodeDET = NULL, Ynode, YnodeDET = NULL,
  IDnode = NULL, NETIDnode = NULL, sep = " ", NETIDmat = NULL, f_gstar1,
  f_gstar2 = NULL, Qform = NULL, hform.g0 = NULL, hform.gstar = NULL,
  verbose = getOption("tmlenet.verbose"), optPars = list(alpha = 0.05,
  lbound = 0.005, family = "binomial", n_MCsims = ceiling(sqrt(nrow(data))),
  runTMLE = c("tmle.intercept", "tmle.covariate"), f_g0 = NULL,
  h_g0_SummariesModel = NULL, h_gstar_SummariesModel = NULL))
}
\arguments{
\item{data}{Input observed data as a \code{data.frame}, with named columns for baseline covariates (W),
assigned treatment (A), the outcome (Y) and network of friends (F)}

\item{Kmax}{Maximal number of friends (connected units) for any observation in the input \code{data} data.frame.}

\item{sW}{Summary measures constructed from baseline covariates alone. This must be an object of class
\code{DefineSummariesClass} that is returned by calling the function \code{\link{def.sW}}.}

\item{sA}{Summary measures constructed from \code{Anode} and baseline covariates. This must be an object of class
\code{DefineSummariesClass} that is returned by calling the function \code{\link{def.sW}}.}

\item{Anode}{Treatment variable name (column name in \code{data}), can be either binary, categorical or continuous.
This can instead be specified with argument \code{sA} by adding a call \code{+def.sA(Anode="ExposureVarName")} to \code{sA}.}

\item{AnodeDET}{(Optional) Column name for indicators of deterministic values of A, coded as (TRUE/FALSE) or (1/0),
the observations with AnodeDET=TRUE/1 are assumed to have constant value for their Anode}

\item{Ynode}{Outcome variable name (column name in \code{data}), assumed normalized 0 to 1. This can instead be specified
on the left-side of the regression formula in argument \code{Qform}.}

\item{YnodeDET}{(Optional) Column name for indicators of deterministic values of outcome Y, coded as (TRUE/FALSE) or (1/0),
the observations with YnodeDET=TRUE/1 are assumed to have constant value for their Ynode}

\item{IDnode}{Subject identifier variable in the input data, if not supplied the network string in
NETIDnode is assumed to be indexing the row numbers in the input \code{data}}

\item{NETIDnode}{Network specification, a column name in data consisting of strings that identify the unit's friends
by their IDs or their row numbers (two friends are separated by space, e.g., "1 2"; unit with no friends should have
an empty "" string). See Details.}

\item{sep}{A character separating friend indices for the same observation in \code{NETIDnode}.}

\item{NETIDmat}{Alternative method for network specification, ths must be a matrix (\code{ncol=Kmax},
\code{nrow=nrow(data)}), where each row \code{i} is a vector of \code{i}'s friends IDs or \code{i}'s friends row
numbers in \code{data} if \code{IDnode=NULL}. See Details.}

\item{f_gstar1}{Either an function or a vector of counterfactual exposures. If a function is specified, it must return
a vector of counterfactual exposures evaluated based on the summary measures matrix (\code{sW,sA}) passed as a named
argument \code{"data"}, therefore, the function in \code{f_gstar1} must have a named argument \code{"data"} in its signature.
The interventions defined by \code{f_gstar1} can be static, dynamic or stochastic. If \code{f_gstar1} is specified as a
vector, it must be of length \code{nrow(data)} or 1 (constant treatment assigned to all observations).
See Details below and Examples "EQUIVALENT WAYS OF SPECIFYING INTERVENTIONS \code{f_gstar1}/\code{f_gstar2}" for demonstration.}

\item{f_gstar2}{Either a function or a vector of counterfactual exposure assignments.
Used for estimating contrasts (average treatment effect) for two interventions, if omitted, only the average
counterfactual outcome under intervention \code{f_gstar1} is estimated. The requirements for \code{f_gstar2}
are identical to those for \code{f_gstar1}.}

\item{Qform}{Regression formula for outcome in Ynode, when omitted (\code{NULL}) Ynode is regressed on all
variables defined in \code{sW} and \code{sA}. See Details.}

\item{hform.g0}{Regression formula for estimating the conditional probability of P(sA | sW) under g0
(the observed treatment mechanism), when omitted (\code{NULL}), will include all variables (columns)
in \code{sA} and in \code{sW}. See Details.}

\item{hform.gstar}{Regression formula for estimating the conditional probability P(sA | sW) under gstar,
when omitted (\code{NULL}), the same regression formula as in \code{hform.g0} will be used. See Details.}

\item{verbose}{Set to \code{TRUE} to print messages on status and information to the console.
Turn this on by default using \code{options(tmlenet.verbose=TRUE)}.}

\item{optPars}{A named list of additional optional parameters to be passed to \code{tmlenet}, such as
 \code{alpha}, \code{lbound}, \code{family}, \code{n_MCsims}, \code{f_g0}, \code{h_g0_SummariesModel} and
 \code{h_gstar_SummariesModel}. See Details.}
}
\value{
A named list of the target parameter estimates of the population mean under intervention \code{f_gstar1}
 (EY_gstar1), their asymptotic variance estimates and CI estimates at \code{alpha} level.
 If \code{f_gstar2} was also specified, the list will consists of the three sets of estimates,
 the first for the target parameter estimates under \code{f_gstar1} (EY_gstar1), the second for estimates under
 \code{f_gstar2} (EY_gstar2) and
 the third for the estimates of the additive treatment effect (EY_gstar1 - EY_gstar2) under intervention in
 \code{f_gstar1} vs. intervention in \code{f_gstar2}.

Currently available estimators are:
 \itemize{
 \item \code{tmle} - Either weighted regression intercept-based TMLE (\code{tmle.intercept} - the default)
 with weights \code{h_gstar/h_gN} or
 covariate-based unweighted TMLE (\code{tmle.covariate}) that uses the covariate \code{h_gstar/h_gN}.
 \item \code{h_iptw} - Efficient IPTW based on weights h_gstar/h_gN.
 \item \code{gcomp} - Parametric G-computation substitution estimator.
}
}
\description{
Estimate the average network effect among dependent units with known network structure (in presence of
 interference and/or spillover) using \strong{TMLE} (targeted maximum likelihood estimation), \strong{IPTW}
 (Horvitz-Thompson or the inverse-probability-of-treatment) and \strong{GCOMP} (parametric G-computation formula).
}
\section{Details}{


Note that when observation \code{i} has only \code{j-1} friends, the i's value of \code{"W_netFj"} is
 automatically set to \code{NA}.
 This can be an undersirable behavior in some circumstances, in which case one can automatically replace all such
 \code{NA}'s with \code{0}'s by setting the argument \code{replaceMisVal0 = TRUE} when calling function
 \code{def.sW}, i.e., \code{def.sW(W_netF1 = W[[1]], replaceMisVal0 = TRUE)}.

When \code{NETIDnode} or \code{NETIDmat} are left unspecified, the input data is assumed independent, with no
 network structure. All inference will be performed based on the iid efficient influence curve for the target
 parameter (EY_gstar1). Note that the ordering of the friends in \code{NETIDnode} or \code{NETIDmat} is unimportant.

An additional special non-negative-integer-valued variable \code{nF} is automatically evaluated each time
 \code{tmlenet} or \code{eval.summaries} functions are called. \code{nF} contains the total number of friends for
 each observation and it is always added as an additional column to the matrix of the baseline-covariates-based
 summary measures \code{sWmat}. The variable \code{nF} can be used in the same ways as any of the column names in
 the input data frame \code{data}. In particular, the name \code{nF} can be used inside the summary measure
 expressions (calls to functions \code{def.sW} and \code{def.sA}) and inside any of the regression formulas
 (\code{Qform}, \code{hform.g0}, \code{hform.gstar}).


The formalas in \code{Qform}, \code{hform.g0} and \code{hform.gstar} can include any summary measures defined in
 sW and sA, referenced by their individual variable names or by their aggregate summary measure names.
 For example, \code{hform.g0 = "netA ~ netW"} is equivalent to
 \code{hform.g0 = "A + A_netF1 + A_netF2 ~ W + W_netF1 + W_netF2"} for \code{sW,sA} summary measures defined by
 \code{def.sW(netW=W[[0:2]], noname=TRUE)} and \code{def.sA(netA=A[[0:2]], noname=TRUE)}.

Additional optional parameters that can be passed inside a named list \code{optPars} include:
 \itemize{
 \item \code{alpha} - alpha-level for CI calculation (0.05 for 95% CIs);
 \item \code{lbound} - One value for symmetrical bounds on P(sW | sW).
 \item \code{n_MCsims} - Number of Monte-Carlo simulations to perform when evaluating P(sA | sW) under gstar and
 f_g0 (if specified) and while evaluating the target parameter estimator under gstar;
 \item \code{family} - Family specification for regression models, defaults to binomial (CURRENTLY ONLY BINOMIAL
 FAMILY IS IMPLEMENTED).
\item \code{f_g0} - A function for generating true treatment mechanism A, when it is known (for example in a
 randomized trial). Used only when estimating P(sA | sW) under g0 by sampling large vector of A
 (of length n*n_MCsims) from \code{f_g0};
}
}

\section{Specifying the counterfactual intervention as functions (\code{f_gstar1} and \code{f_gstar2})}{

The functions \code{f_gstar1} and \code{f_gstar2} can only depend on variables specified by the combined matrix
 of summary measures (\code{sW},\code{sA}), which is passed using the argument \code{data}. The functions should
 return a vector of length \code{nrow(data)} of counterfactual treatments for observations in the input data.
}

\section{Specifying the Network of Friends}{


The network of friends (connections) for observations in the input \code{data} can be specified in two
 alternative ways, using either \code{NETIDnode} or \code{NETIDmat} input arguments.

\code{NETIDnode} - The first (slower) method uses a vector of strings in \code{data[, NETIDnode]}, where each
 string \code{i} must contain the space separated IDs or row numbers of all units in \code{data} thought to be
 connected to observation i (friends of unit i);

\code{NETIDmat} - An alternative (and faster) method is to pass a matrix with \code{Kmax} columns and nrow(data)
 rows, where each row \code{NETIDmat[i,]} is a vector of observation \code{i}'s friends' IDs or \code{i}'s friends'
 row numbers in \code{data} if \code{IDnode=NULL}. If observation \code{i} has fewer than \code{Kmax} friends, the
 remainder of \code{NETIDmat[i,]} must be filled with \code{NA}s. Note that the ordering of friend indices is
 irrelevant.
}

\section{IPTW estimator}{

**********************************************************************

*) Fit one density for P_{g_0}(\code{sA} | \code{sW}) implied by (\code{A},\code{W})~g_0(\code{A}|\code{W})Q_0(\code{W})
   and another density for P_{g_star}(\code{sA^*} | \code{sW^*}) that is implied by (\code{A^*},\code{W})~g_star(\code{A}|\code{W})Q_0(\code{W}).

*) Same algorithm is used for estimating P_{g_0}(\code{sA} | \code{sW}) and P_{\code{f_gstar}}(\code{sA^*} | \code{sW}) (see below).

*) These two density estimates form the basis of the IPTW estimator,
   which is evaluated at the observed N data points \code{o_i}=(\code{y_i}, \code{sa_i}, \code{sw_i}), i=1,...,N.
   The IPTW is then given by \code{psi_n} = \\sum_i={1,...,N} {\code{Y_i} *
   P_{\code{f_gstar}}(\code{sA^*} = \code{sa_i} | \code{sW}=\code{sw_i}) / P_{\code{g_N}}(\code{sA}=\code{sa_i} | \code{sW}=\code{sw_i})}.
}

\section{Algorithm for estimating P(\code{sA} | \code{sW}) for continuous one-dimenstional summary measure \code{sA}}{

**********************************************************************

*) For simplicity, suppose \code{sA} is continuous and univariate and we describe here an algorithm for fitting P_{\code{g_0}}(\code{sA} | \code{sW}) (the algorithm
 for fitting P_{\code{f_gstar}}(\code{sA^*} | \code{sW^*}) is eqivalent, except that exposure \code{A} is replaced with exposure \code{A^*} generated under \code{f_gstar} and
 the predictors \code{sW} from the regression formula \code{hform.g0} are replaced with predictors \code{sW^*} specified by the regression formula \code{hform.gstar}).

1) Generate a dataset of N observed continuous summary measures (\code{sa_i}:i=1,...,N) from observed ((\code{a_i},\code{w_i}):i=1,...,N). Let \code{sa}\\in{\code{sa_i}:i=1,...,M}.

2) Divide the range of \code{sA} values into intervals S=(i_1,...,i_M,i_{M+1}) so that any observed data point \code{sa_i} belongs to one interval in S, namely,
   for each possible value sa of \code{sA} there is k\\in{1,...,M}, such that, i_k < \code{sa} <= i_{k+1}.
   Let the mapping B(sa)\\in{1,...,M} denote a unique interval in S for sa, such that, i_{B(sa)} < sa <= i_{B(sa)+1}.
   Let bw_{B(sa)}:=i_{B(sa)+1}-i_{B(sa)} be the length of the interval (bandwidth) (i_{B(sa)},i_{B(sa)+1}).
   Also define the binary indicators b_1,...,b_M, where b_j:=I(B(sa)=j), for all j <= B(sa) and b_j:=NA for all j>B(sa).
   That is we set b_j to missing ones the indicator I(B(sa)=j) jumps from 0 to 1.
   Now let \code{sA} denote the random variable for the observed summary measure for one unit
   and denote by (B_1,...,B_M) the corresponding random indicators for \code{sA} defined as B_j := I(B(\code{sA}) = j)
   for all j <= B(\code{sA}) and B_j:=NA for all j>B(\code{sA}).

3) For each j=1,...,M, fit the logistic regression model for the conditional probability P(B_j = 1 | B_{j-1}=0, sW), i.e.,
   at each j this is defined as the conditional probability of B_j jumping from 0 to 1 at bin j, given that B_{j-1}=0 and
   each of these logistic regression models is fit only among the observations that are still at risk of having B_j=1 with B_{j-1}=0.
4) Normalize the above conditional probability of B_j jumping from 0 to 1 by its corresponding interval length (bandwidth) bw_j to
   obtain the discrete conditional hazards h_j(sW):=P(B_j = 1 | (B_{j-1}=0, sW) / bw_j, for each j.
   For the summary measure \code{sA}, the above conditional hazard h_j(sW) is equal to P(\code{sA} \\in (i_j,i_{j+1}) | \code{sA}>=i_j, sW),
   i.e., this is the probability that \code{sA} falls in the interval (i_j,i_{j+1}), conditional on sW and conditional on the fact that
   \code{sA} does not belong to any intervals before j.

5) Finally, for any given data-point \code{(sa,sw)}, evaluate the discretized conditional density for P(\code{sA}=sa|sW=sw) by first
   evaluating the interval number k=B(sa)\\in{1,...,M} for \code{sa} and then computing \\prod{j=1,...,k-1}{1-h_j(sW))*h_k(sW)}
   which is equivalent to the joint conditional probability that \code{sa} belongs to the interval (i_k,i_{k+1}) and does not belong
   to any of the intervals 1 to k-1, conditional on sW.

   The evaluation above utilizes a discretization of the fact that any continuous density f of random variable X can be written as f_X(x)=S_X(x)*h_X(x),
   for a continuous density f of X where S_X(x):=P(X>x) is the survival function for X, h_X=P(X>x|X>=x) is the hazard function for X; as well as the fact that
   the discretized survival function S_X(x) can be written as a of the hazards for s<x: S_X(x)=\\prod{s<x}h_X(x).
}

\section{Three methods for defining bin (interval) cuttoffs for a continuous one-dimenstional summary measure \code{sA[j]}}{

**********************************************************************

There are 3 alternative methods to defining the bin cutoffs S=(i_1,...,i_M,i_{M+1}) for a continuous summary measure \code{sA}
The choice of which method is used along with other discretization parameters (e.g., total number of bins) is controlled via the tmlenet_options() function.
See \code{?tmlenet_options} argument \code{bin.method} for additional details.

Approach 1 (\code{equal.len}): equal length, default.

*********************

The bins are defined by splitting the range of observed \code{sA} (sa_1,...,sa_n) into equal length intervals.
This is the dafault discretization method, set by passing an argument \code{bin.method="equal.len"} to \code{tmlenet_options} function prior to calling \code{tmlenet()}.
The intervals will be defined by splitting the range of (sa_1,...,sa_N) into \code{nbins} number of equal length intervals,
where \code{nbins} is another argument of \code{tmlenet_options()} function.
When \code{nbins=NA} (the default setting) the actual value of \code{nbins} is computed at run time by taking the integer value (floor) of \code{n/maxNperBin},
for \code{n} - the total observed sample size and \code{maxNperBin=1000} - another argument of \code{tmlenet_options()} with the default value 1,000.

Approach 2 (\code{equal.mass}): data-adaptive equal mass intervals.

*********************

The intervals are defined by splitting the range of \code{sA} into non-equal length data-adaptive intervals that ensures that each interval contains around
\code{maxNperBin} observations from (sa_j:j=1,...,N).
This interval definition approach can be selected by passing an argument \code{bin.method="equal.mass"} to \code{tmlenet_options()} prior to calling \code{tmlenet()}.
The method ensures that an approximately equal number of observations will belong to each interval, where that number of observations for each interval
is controlled by setting \code{maxNperBin}. The default setting is \code{maxNperBin=1000} observations per interval.

Approach 3 (\code{dhist}): combination of 1 & 2.

*********************

The data-adaptive approach dhist is a mix of Approaches 1 & 2. See Denby and Mallows "Variations on the Histogram" (2009)).
This interval definition method is selected by passing an argument \code{bin.method="dhist"} to \code{tmlenet_options()}  prior to calling \code{tmlenet()}.
}
\examples{
#***************************************************************************************
# TO DO: 
# (1) ADD AN EXAMPLE WITH STOCHASTIC INTERVENTION
# (2) ADD AN EXAMPLE WITH CONTINUOUS EXPOSURE

#***************************************************************************************
data(df_netKmax6) # Load the network data
Kmax <- 6 # Max number of friends in the network
#***************************************************************************************

#***************************************************************************************
# EXAMPLES OF INTERVENTION FUNCTIONS:
#***************************************************************************************
# Returns a function that will sample A with probability x:=P(A=1))
make_f.gstar <- function(x, ...) {
  eval(x)
  f.A_x <- function(data, ...){
    rbinom(n = nrow(data), size = 1, prob = x[1])
  }
  return(f.A_x)
}
# Deterministic f_gstar setting every A=0:
f.A_0 <- make_f.gstar(x = 0)
# Deterministic f_gstar setting every A=1:
f.A_1 <- make_f.gstar(x = 1)
# Stochastically sets (100*x)\% of population to A=1 with probability 0.2:
f.A_.2 <- make_f.gstar(x = 0.2)

#***************************************************************************************
# DEFINING SUMMARY MEASURES:
#***************************************************************************************
def_sW <- def.sW(netW2 = W2[[1:Kmax]]) +
          def.sW(sum.netW3 = sum(W3[[1:Kmax]]), replaceNAw0=TRUE)

def_sA <- def.sA(sum.netAW2 = sum((1-A[[1:Kmax]])*W2[[1:Kmax]]), replaceNAw0=TRUE) +
          def.sA(netA = A[[0:Kmax]])

#***************************************************************************************
# EVALUATING SUMMARY MEASURES FROM INPUT DATA
#***************************************************************************************
# A helper function that can pre-evaluate the summary measures on (O)bserved data:
res <- eval.summaries(sW = def_sW, sA = def_sA,  Kmax = 6, data = df_netKmax6,
  NETIDmat = NetInd_mat_Kmax6, verbose = TRUE)

#***************************************************************************************
# Specifying the clever covariate regressions hform.g0 and hform.gstar:
# Left side can consist of any summary names defined by def.sA (as linear terms)
# Right side can consist of any summary names defined by def.sW (as linear terms) & 'nF'
#***************************************************************************************
hform.g01 <- "netA ~ netW2 + sum.netW3 + nF"
hform.gstar1 <- "netA ~ sum.netW3"

# alternatives:
hform.g02 <- "netA + sum.netAW2 ~ netW2 + sum.netW3 + nF"
hform.g03 <- "sum.netAW2 ~ netW2 + sum.netW3"

#***************************************************************************************
# SPECIFYING the outcome regression Qform:
# Left side is ignored (with a warning if not equal to Ynode)
# Right side can by any summary names defined by def.sW, def.sA & 'nF'
#***************************************************************************************
Qform1 <- "Y ~ sum.netW3 + sum.netAW2"
Qform2 <- "Y ~ netA + netW + nF"
Qform3 <- "blah ~ netA + netW + nF"

#***************************************************************************************
# Estimate mean population outcome under deterministic intervention A=0 with 6 friends:
# ESTIMATION WITH regression formulas
#***************************************************************************************
# Note that Ynode is optional when Qform is specified;
options(tmlenet.verbose = FALSE) # set to TRUE to print status messages
res_K6_1 <- tmlenet(data = df_netKmax6, Kmax = Kmax, sW = def_sW, sA = def_sA,
                    Qform = "Y ~ sum.netW3 + sum.netAW2",
                    hform.g0 = "netA ~ netW2 + sum.netW3 + nF",
                    hform.gstar = "netA ~ sum.netW3",
                    Anode = "A", f_gstar1 = 0L,
                    IDnode = "IDs", NETIDnode = "Net_str", sep = ' ',
                    optPars = list(runTMLE = "tmle.intercept", n_MCsims = 10))

res_K6_1$EY_gstar1$estimates
res_K6_1$EY_gstar1$vars
res_K6_1$EY_gstar1$CIs

#***************************************************************************************
# Same as above but for covariate-based TMLE.
#***************************************************************************************
res_K6_2 <- tmlenet(data = df_netKmax6, Kmax = Kmax, sW = def_sW, sA = def_sA,
                    Qform = "Y ~ sum.netW3 + sum.netAW2",
                    hform.g0 = "netA ~ netW2 + sum.netW3 + nF",
                    hform.gstar = "netA ~ sum.netW3",
                    Anode = "A", f_gstar1 = 0L,
                    IDnode = "IDs", NETIDnode = "Net_str", sep = ' ',
                    optPars = list(runTMLE = "tmle.covariate", n_MCsims = 10))

res_K6_2$EY_gstar1$estimates
res_K6_2$EY_gstar1$vars
res_K6_2$EY_gstar1$CIs

#***************************************************************************************
# SPECIFYING THE NETWORK AS A MATRIX OF FRIEND ROW NUMBERS:
#***************************************************************************************
net_ind_obj <- simcausal::NetIndClass$new(nobs = nrow(df_netKmax6), Kmax = Kmax)

# generating the network matrix from input data:
NetInd_mat <- net_ind_obj$makeNetInd.fromIDs(Net_str = df_netKmax6[, "Net_str"],
                                              IDs_str = df_netKmax6[, "IDs"],
                                              sep = ' ')$NetInd
# number of friends:
nF <- net_ind_obj$nF

data(NetInd_mat_Kmax6)
all.equal(NetInd_mat, NetInd_mat_Kmax6) # TRUE

print(head(NetInd_mat))
print(head(nF))
print(all.equal(df_netKmax6[,"nFriends"], nF))

res_K6_net1 <- tmlenet(data = df_netKmax6, Kmax = Kmax, sW = def_sW, sA = def_sA,
                        Qform = "Y ~ sum.netW3 + sum.netAW2",
                        hform.g0 = "netA ~ netW2 + sum.netW3 + nF",
                        hform.gstar = "netA ~ sum.netW3",
                        Anode = "A", f_gstar1 = f.A_0,
                        NETIDmat = NetInd_mat,
                        optPars = list(runTMLE = "tmle.intercept", n_MCsims = 10))

all.equal(res_K6_net1$EY_gstar1$estimates, res_K6_1$EY_gstar1$estimates)
all.equal(res_K6_net1$EY_gstar1$vars, res_K6_1$EY_gstar1$vars)
all.equal(res_K6_net1$EY_gstar1$CIs, res_K6_1$EY_gstar1$CIs)

#***************************************************************************************
# (*) EQUIVALENT WAYS OF SPECIFYING INTERVENTIONS f_gstar1/f_gstar2.
# (*) LOWERING THE DIMENSIONALITY OF THE SUMMARY MEASURES.
#***************************************************************************************
def_sW <- def.sW(sum.netW3 = sum(W3[[1:Kmax]]), replaceNAw0=TRUE)
def_sA <- def.sA(sum.netAW2 = sum((1-A[[1:Kmax]])*W2[[1:Kmax]]), replaceNAw0=TRUE)

# can define intervention by function f.A_0 that sets everyone's A to constant 0:
res_K6_1 <- tmlenet(data = df_netKmax6, Kmax = Kmax, sW = def_sW, sA = def_sA,
                    Anode = "A", Ynode = "Y", f_gstar1 = f.A_0,
                    IDnode = "IDs", NETIDnode = "Net_str")
res_K6_1$EY_gstar1$estimates

# equivalent way to define intervention f.A_0 is to just set f_gstar1 to 0:
res_K6_1 <- tmlenet(data = df_netKmax6, Kmax = Kmax, sW = def_sW, sA = def_sA,
                    Anode = "A", Ynode = "Y", f_gstar1 = 0L,
                    IDnode = "IDs", NETIDnode = "Net_str")
res_K6_1$EY_gstar1$estimates

# or set f_gstar1 to a vector of 0's of length nrow(data):
res_K6_1 <- tmlenet(data = df_netKmax6, Kmax = Kmax, sW = def_sW, sA = def_sA,
                    Anode = "A", Ynode = "Y", f_gstar1 = rep_len(0L, nrow(df_netKmax6)),
                    IDnode = "IDs", NETIDnode = "Net_str")
res_K6_1$EY_gstar1$estimates


#***************************************************************************************
# EXAMPLE WITH SIMULATED DATA FOR 2 FRIENDS AND 1 COVARIATE W1 (SIMULATION 1)
#***************************************************************************************
# data(df_netKmax2)
# head(df_netKmax2)
# #--------------------------------------------------------
# # Define regression formulas for Q and g
# #--------------------------------------------------------
# Qform <- "Y ~  W1 + A + netW1_1 + netW1_2 + netA_1 + netA_2 + nF"
# # gform <- "A ~  W1 + netW1_1 + netW1_2 + nF"

# #***************************************************************************************
# # Mean population outcome under stochastic intervention P(A=1)=0.2
# #***************************************************************************************
# Net_str <- df_netKmax6[, "Net_str"]
# IDs_str <- df_netKmax6[, "IDs"]
# net_ind_obj <- simcausal::NetIndClass$new(nobs = nrow(df_netKmax6), Kmax = Kmax)
# net_ind_obj$makeNetInd.fromIDs(Net_str = Net_str, IDs_str = IDs_str, sep = ' ')
# NetInd_mat <- net_ind_obj$NetInd

# tmlenet_out2 <- tmlenet(data = df_netKmax2, Anode = "A", Ynode = "Y",
#                         Kmax = 2, IDnode = "IDs", NETIDnode = "Net_str",
#                         Qform = Qform, gform = gform,
#                         f.g1.star = f.A_.2,
#                         n_MCsims = 4000, n_samp_g0gstar = 100)

# # TMLE estimate and iid IC-based 95\% CI:
# tmlenet_out2$estimates$EY_g1.star$tmle_B
# tmlenet_out2$estimates$EY_g1.star$CI_tmle_B_iidIC

# # Efficient IPTW (h) and iid IC-based 95\% CI:
# tmlenet_out2$estimates$EY_g1.star$iptw_h
# tmlenet_out2$estimates$EY_g1.star$CI_iptw_h_iidIC

# # Inefficient IPTW (g) + (two CIs, less conservative and more conservative)
# tmlenet_out2$estimates$EY_g1.star$iptw
# tmlenet_out2$estimates$EY_g1.star$CI_iptw_iidIC_1stO
# tmlenet_out2$estimates$EY_g1.star$CI_iptw_iidIC_2ndO

# # MLE
# tmlenet_out2$estimates$EY_g1.star$mle

# #***************************************************************************************
# # Average treatment effect (ATE) for two interventions, f.g1.star: A=1 vs f.g2.star: A=0
# #***************************************************************************************
# tmlenet_out3 <- tmlenet(data = df_netKmax2, Anode = "A", Ynode = "Y",
#                         Kmax = 2, IDnode = "IDs", NETIDnode = "Net_str",
#                         Qform = Qform, gform = gform,
#                         f.g1.star = f.A_1, f.g2.star = f.A_0,
#                         n_MCsims = 4000, n_samp_g0gstar = 100)

# # TMLE estimate for ATE + 95\% CI
# tmlenet_out3$estimates$ATE$tmle_B
# tmlenet_out3$estimates$ATE$CI_tmle_B_iidIC

# # Efficient IPTW (h) and iid IC-based 95\% CI:
# tmlenet_out3$estimates$ATE$iptw_h
# tmlenet_out3$estimates$ATE$CI_iptw_h_iidIC

# # Inefficient IPTW (g) + (two CIs, less conservative and more conservative)
# tmlenet_out3$estimates$ATE$iptw
# tmlenet_out3$estimates$ATE$CI_iptw_iidIC_1stO
# tmlenet_out3$estimates$ATE$CI_iptw_iidIC_2ndO

# # MLE
# tmlenet_out3$estimates$ATE$mle









}
\seealso{
\code{\link{tmlenet-package}} for the general overview of the package,
 \code{\link{def.sW}} for defining the summary measures, \code{\link{eval.summaries}} for
 evaluation and validation of the summary measures,
 and \code{\link{df_netKmax2}}/\code{\link{df_netKmax6}}/\code{\link{NetInd_mat_Kmax6}}
 for examples of network datasets.
}

